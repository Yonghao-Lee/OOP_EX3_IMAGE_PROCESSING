omer.cohen8,yonghao.lee
326774313,345906150

1. תיאור המחלקות והקשרים ביניהן:
   * Shell: מחלקה זו משמשת כ-Controller וכממשק המשתמש (CLI). היא אחראית על קבלת הקלט, ניתוח הפקודות (Parsing), וניהול מצב התוכנית (רזולוציה, גודל המאגר, ושיטת הפלט). המחלקה משתמשת במחלקות Image ו-SubImgCharMatcher ומפעילה את ה-AsciiArtAlgorithm כדי לייצר את הפלט הסופי.

   * AsciiArtAlgorithm: ה"מנוע" של התוכנית. אחראית על הלוגיקה של המרת תמונה ל-ASCII. היא מפעילה את ImageProcessing לביצוע חישובים על התמונה (ריפוד, חלוקה, בהירות) ומשתמשת ב-SubImgCharMatcher כדי למצוא את התו המתאים ביותר לכל משבצת. כמו כן, המחלקה מנהלת מנגנון Caching (באמצעות שדות סטטיים) כדי לייעל חישובים בריצות חוזרות.

   * ImageProcessing: מחלקת עזר (Utility Class) שהוספנו. מכילה מתודות סטטיות לביצוע מניפולציות מתמטיות על התמונה: ריפוד התמונה לחזקות של 2 (padImage), חלוקת התמונה לתתי-תמונות (divideImage), וחישוב בהירות ממוצעת. השימוש במחלקה זו שומר על עקרון האחריות היחידה (SRP) ומונע עומס על מחלקת Image.

   * SubImgCharMatcher: אחראית על ניהול מאגר התווים והתאמתם לבהירות. המחלקה מחזיקה את התווים ממוינים לפי בהירות ומבצעת חיפוש של התו הקרוב ביותר (Nearest Neighbor) עבור בהירות נתונה, תוך תמיכה במצבי reverse.

2. מבני הנתונים בהם השתמשנו:
   * TreeMap<Double, TreeSet<Character>> (במחלקה SubImgCharMatcher):
     שימוש: המפתח הוא רמת הבהירות (Double) והערך הוא קבוצת תווים (TreeSet) בעלי אותה בהירות.
     הסבר: בחרנו ב-TreeMap מכיוון שאנו צריכים למצוא את הבהירות הכי קרובה לערך נתון (ולא בהכרח זהה). המתודות floorKey ו-ceilingKey מאפשרות חיפוש זה בסיבוכיות O(log n). השימוש ב-TreeSet כערך המפה שומר על התווים ממוינים לפי ה-ASCII שלהם, מה שמאפשר שליפה של התו המינימלי במקרה של שוויון בבהירות בסיבוכיות O(1).

   * double[][] (במחלקה AsciiArtAlgorithm):
     שימוש: המערך cachedBrightnessMatrix שומר את ערכי הבהירות שחושבו עבור תתי-התמונות בריצה הקודמת.
     הסבר: גישה לתא במערך דו-מימדי היא בסיבוכיות O(1). זהו המבנה היעיל ביותר (בזמן ובזיכרון) לשמירת מטריצה בגודל קבוע ידוע מראש.

3. מנגנון החריגות (Exceptions):
   תכננו את הקוד כך שחריגה שנזרקת מכל מקום בתכנית תתפס במתודה run או בשלב מוקדם יותר כדי לזרוק שגיאה אינפורמטיבית יותר.
   הגדרתי שלושה חריגות חדשות שכל אחת מהן מתארת שגיאה מסוג אחר בתכנית, ספציפיות יותר מהשגיאות הדיפולטיביות שמסופקות על ידי java:
   * החריגה CommandFormatException נזרקת כתוצאה מפורמט לא חוקי של פקודה מהמשתמש.
   * פקודה שלא קיימת מהמשתמש תזרוק שגיאה מסוג InvalidCommandException.
   * לבסוף, השגיאה ResolutionStateException תזרק על ידי המתודה setResolution כאשר הרזולוציה החדשה אינה בטווח הראוי.
   שלושת החריגות הללו יורשות מ-RuntimeExceptions, שכן הן נובעות מקלט של המשתמש שלא ידוע עד זמן הריצה.

4. שינויים ב-API של SubImgCharMatcher:
   הוספנו למחלקה שתי מתודות פומביות כדי לתמוך בדרישות ה-Shell (חלק ב' של התרגיל):
   * public TreeSet<Character> getChars(): הוספנו מתודה זו כדי לאפשר למחלקה Shell לקבל את רשימת כל התווים הקיימים במאגר ולהדפיס אותם למשתמש (עבור הפקודה chars).
   * public void setReverse(boolean reverse): הוספנו מתודה זו כדי לאפשר למשתמש לשנות את מצב הפעולה (רגיל/הפוך) באמצעות הפקודה reverse ב-Shell. המתודה מעדכנת דגל פנימי המשפיע על חישוב הבהירות המבוקשת, מבלי שנצטרך ליצור את האובייקט מחדש.

5. שינויים בקוד שסופק:
   לא ביצענו שינויים בקוד המקורי של המחלקות שסופקו (Image, CharConverter וכו').
   את הלוגיקה של עיבוד התמונה (ריפוד, חלוקה וחישוב בהירות) מימשנו במחלקה חדשה שיצרנו בשם ImageProcessing (בחבילת image), וזאת כדי להימנע משינוי ה-API של Image וכדי לשמור על חלוקת אחריות ברורה בקוד.